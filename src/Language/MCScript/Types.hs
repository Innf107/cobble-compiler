{-# LANGUAGE NoImplicitPrelude, DataKinds, TypeFamilies, StandaloneDeriving, FlexibleInstances #-}
{-# LANGUAGE GADTs, RankNTypes#-}
module Language.MCScript.Types where

import Language.MCScript.Prelude

type Name = Text

-- Top level module. 
data Module (t :: Typing) = Module Name [Statement t] --deriving (Show, Eq)

-- | A data kind representing the typing level of an expression.
-- `Statement 'Typed` or `Expr 'Typed` should only be generated by
-- the typechecker
data Typing = Typed | Untyped

-- | A type family representing the contents of a (possibly) typed expression.
-- If `t == 'Typed`, this contains the type of the expression.
type family TypedExpr (t :: Typing) where
    TypedExpr 'Untyped = Expr 'Untyped
    TypedExpr 'Typed = (Expr 'Typed, Type)

-- | A class to extract the expression from a TypedExpr, (possibly) removing the type
class TypedExprContent (t :: Typing) where typedExprContent :: TypedExpr t -> Expr t
instance TypedExprContent 'Untyped where typedExprContent = id
instance TypedExprContent 'Typed where typedExprContent = fst

data Statement (t::Typing) =
      CallVoid Name [TypedExpr t]
    | CallFun Name [TypedExpr t] 
    | DefVoid Name [(Name, Type)] [Statement t]
    | DefFun Name [(Name, Type)] [Statement t] (TypedExpr t) Type
--                                                       ^ last expr
    | Decl Name Type (TypedExpr t)
    | Assign Name (TypedExpr t)
    | While (TypedExpr t) [Statement t]
--    | Return Expr   -- potentially very hard to implement?
    | DefStruct Name [(Name, Type)]
               
deriving instance Show (Statement 'Typed)
deriving instance Show (Statement 'Untyped)
deriving instance Eq (Statement 'Typed)
deriving instance Eq (Statement 'Untyped)


data Expr (t :: Typing) =
      FCall Name [TypedExpr t]
    | IntLit Int
          --  | FloatLit Double Text TODO: Needs Standard Library (Postfixes?)
    | BoolLit Bool
    | Var Name

deriving instance Show (Expr 'Typed)
deriving instance Show (Expr 'Untyped)
deriving instance Eq (Expr 'Typed)
deriving instance Eq (Expr 'Untyped)


data Type = IntT | BoolT | EntityT | StructT Name deriving (Show, Eq)



{- Postfixes:
1.23 -> 1.23f -> FloatLit 1.23 "f" -> mkFloat(123, -3)

postfix "f" mkFloat;

Float mkFloat (exponent: Int, mantissa: Int) {
    Float {
      exponent = exponent
    , mantissa = mantissa
    }
}

postfix "r" mkRational;

Rational mkRational (exponent: Int, mantissa: Int) {
    ...
}

-}

{- Floats:

1,5 = 15 * 10^-1 (As Library Struct)

Struct:
    struct Float {
      exponent: Int
    , mantissa: Int
    }

    // (x * 10^a) * (y * 10^b) = (x * y) * (10^a * 10^b) = (x * y) * (10^(a + b))
    Float mulFloat(Float x, Float y){
        normalize(Float {
          exponent=x.exponent + y.exponent
        , mantissa=x.mantissa * y.mantissa
        })
    }

    Float int2Float(Int x){
        normalize(Float {exponent=1, mantissa=x})
    }

    Int floor(Float x){
        if (x.exponent >= 0)
            x.mantissa * (10 ^ x.exponent)
        else
            0
    }

    // (x * 10^a) / (y * 10^b) = (x / y) * 10^(a - b)
    Float divFloat(Float x, Float y){

    }


-}


