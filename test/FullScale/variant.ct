--# definition : score
variant IntList = Nil
                | Cons Int IntList;

--! 1
1 

--# construction : score
variant IntList = Nil
                | Cons Int IntList;

x :: IntList;
x = Nil;

--! 1
1

--# recursive construction : score
variant IntList = Nil
                | Cons Int IntList;

x :: IntList;
x = Cons 1 Nil;

--! 1
1

--# partial application : score

variant List a = Nil | Cons a (List a);

f :: (List Int) -> (List Int);
f = Cons 5;

g :: Int -> (List Int) -> (List Int);
g = Cons;

h :: List Int;
h = f (g 5 Nil);

--! 1
1

--# pattern matching : score

variant Identity a = MkIdentity a;

getIdentity :: (Identity a) -> a;
getIdentity i = case i of {
        MkIdentity x -> x;
    };

--! 5
getIdentity (MkIdentity 5)

--# recursive pattern matching : score

variant List a = Nil | Cons a (List a);

sum :: List Int -> Int;
sum l = case l of {
    Nil -> 0;
    Cons x xs -> __add__ x (sum xs);
};

--! 6
sum (Cons 1 (Cons 2 (Cons 3 Nil)))


--# slightly more complex pattern matching : score 
variant List a = Nil | Cons a (List a);

xs :: List Int;
xs = Cons 1 (Cons 2 (Cons 3 Nil));

map :: (a -> b) -> (List a) -> (List b);
map f l = case l of {
        Nil       -> Nil;
        Cons x xs -> Cons (f x) (map f xs); 
    };

add5 :: Int -> Int;
add5 x = __add__ x 5;

sum :: List Int -> Int;
sum l = case l of {
    Nil -> 0;
    Cons x xs -> __add__ x (sum xs);
};

--! 21
sum (map add5 xs)

--# repeated complex pattern matching : score

variant List a = Nil | Cons a (List a);

xs :: List Int;
xs = Cons 1 (Cons 2 (Cons 3 Nil));

map :: (a -> b) -> (List a) -> (List b);
map f l = case l of {
        Nil       -> Nil;
        Cons x xs -> Cons (f x) (map f xs); 
    };


le5 :: Int -> Bool;
le5 x = __le__ x 5;

ys :: List Bool;
ys = map le5 xs;

allTrue :: List Bool -> Bool;
allTrue l = case l of {
        Nil -> __true__ ();
        Cons x xs -> if x then allTrue xs else __false__ ();
    };

boolToInt :: Bool -> Int;
boolToInt x = if x then 1 else 0;

--! 1
boolToInt (allTrue ys)
